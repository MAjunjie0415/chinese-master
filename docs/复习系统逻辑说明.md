# 复习系统逻辑说明

## 📋 概述

复习系统基于**遗忘曲线算法**，自动管理用户的单词复习计划。系统会：
1. 在练习完成后自动创建复习记录
2. 根据用户表现计算下次复习时间
3. 在复习页面显示待复习单词
4. 根据复习结果更新复习计划

---

## 🔄 完整学习闭环

```
选择课程 → 开始练习 → 完成练习 → 自动创建复习记录 → 
查看复习提醒 → 开始复习 → 更新复习时间 → 继续学习
```

---

## 📊 数据流

### 1. 复习记录的创建

#### 场景A：练习完成后（学习模式）

**触发位置**：
- `app/courses/[slug]/practice/picture-match/PictureMatchClient.tsx`
- `app/courses/[slug]/practice/tone-practice/TonePracticeClient.tsx`

**流程**：
```typescript
// 1. 练习完成，收集答题结果
const wordResults = [
  { wordId: 1, isCorrect: true },   // 答对
  { wordId: 2, isCorrect: false },  // 答错
  // ...
];

// 2. 调用工具函数创建复习记录
await createReviewRecords(wordResults);
```

**实现**：`lib/practice-utils.ts`
- 为每个单词调用 `/api/progress` API
- 传递参数：`{ wordId, known: isCorrect, isReview: false }`

#### 场景B：复习页面交互（复习模式）

**触发位置**：
- `app/review/ReviewComponent.tsx`

**流程**：
```typescript
// 用户点击"Still Know"或"Forgot"
const response = await fetch('/api/progress', {
  method: 'POST',
  body: JSON.stringify({
    wordId: currentWord.id,
    known: true/false,  // Still Know = true, Forgot = false
    isReview: true,     // 标记为复习模式
  }),
});
```

---

## ⏰ 复习时间计算算法

**实现位置**：`app/api/progress/route.ts`

### 算法规则

#### 学习模式（`isReview: false`）

| 用户表现 | `known` 值 | 下次复习时间 | 说明 |
|---------|-----------|------------|------|
| 答对 | `true` | **1天后** | 初步掌握，1天后巩固 |
| 答错 | `false` | **1小时后** | 需要快速复习 |

#### 复习模式（`isReview: true`）

| 用户表现 | `known` 值 | 下次复习时间 | 说明 |
|---------|-----------|------------|------|
| 仍掌握 | `true` | **2天后** | 已巩固，延长间隔 |
| 已遗忘 | `false` | **10分钟后** | 需要立即重新学习 |

### 代码实现

```typescript
// app/api/progress/route.ts (第44-66行)

const now = new Date();
let nextReview: Date;

if (isReview) {
  // 复习模式
  if (known) {
    // Still Know：2天后复习
    nextReview = new Date(now.getTime() + 2 * 24 * 60 * 60 * 1000);
  } else {
    // Forgot：10分钟后复习
    nextReview = new Date(now.getTime() + 10 * 60 * 1000);
  }
} else {
  // 学习模式
  if (known) {
    // Know：1天后复习
    nextReview = new Date(now.getTime() + 24 * 60 * 60 * 1000);
  } else {
    // Don't Know：1小时后复习
    nextReview = new Date(now.getTime() + 60 * 60 * 1000);
  }
}
```

---

## 🔍 复习单词查询逻辑

**实现位置**：`app/review/page.tsx`

### 查询条件

1. **用户过滤**：`user_progress.user_id = 当前用户ID`
2. **时间过滤**：`user_progress.next_review < 今天23:59:59`
3. **状态过滤**：`user_progress.mastered = false`（未完全掌握）
4. **来源过滤**：只显示来自 **Courses** 的单词（通过 JOIN `course_words` 和 `courses`）

### SQL查询逻辑

```typescript
// app/review/page.tsx (第29-57行)

const todayEnd = sql`now()::date + interval '1 day' - interval '1 second'`;

const reviews = await db
  .select({
    // words表字段
    id: words.id,
    chinese: words.chinese,
    pinyin: words.pinyin,
    english: words.english,
    // ...
    // courses表字段（课程来源信息）
    courseId: courses.id,
    courseTitle: courses.title,
    courseSlug: courses.slug,
  })
  .from(userProgress)
  .innerJoin(words, eq(userProgress.word_id, words.id))
  .innerJoin(courseWords, eq(userProgress.word_id, courseWords.word_id))
  .innerJoin(courses, eq(courseWords.course_id, courses.id))
  .where(
    and(
      eq(userProgress.user_id, userId),
      lt(userProgress.next_review, todayEnd),
      eq(userProgress.mastered, false)
    )
  );
```

### 关键点

- ✅ **只显示Courses单词**：通过 `INNER JOIN course_words` 确保单词来自课程
- ✅ **显示课程来源**：每个复习单词都会显示来自哪个课程
- ✅ **时间范围**：只显示"今天需要复习"的单词（`next_review < 今天结束`）

---

## 🎯 复习页面交互

**实现位置**：`app/review/ReviewComponent.tsx`

### 交互流程

1. **显示单词**
   - 显示拼音和英文释义
   - 显示课程来源标签（如 "📚 商务谈判核心词汇"）

2. **查看答案**
   - 点击 "Show Answer" 按钮
   - 显示汉字和例句
   - 显示发音按钮

3. **用户反馈**
   - **Still Know**（仍掌握）：
     - 调用 `/api/progress`，`known: true, isReview: true`
     - 更新 `next_review` 为 **2天后**
   - **Forgot**（已遗忘）：
     - 调用 `/api/progress`，`known: false, isReview: true`
     - 更新 `next_review` 为 **10分钟后**

4. **乐观更新**
   - 立即切换到下一个单词（不等待API响应）
   - 如果API失败，自动回滚到上一个单词
   - 显示撤销提示（3秒内可撤销）

---

## 📈 首页复习提醒

**实现位置**：`app/page.tsx`

### 查询逻辑

```typescript
// app/page.tsx (第24-37行)

const todayEnd = sql`now()::date + interval '1 day' - interval '1 second'`;

const result = await db
  .select({ count: count() })
  .from(userProgress)
  .innerJoin(courseWords, eq(userProgress.word_id, courseWords.word_id))
  .innerJoin(courses, eq(courseWords.course_id, courses.id))
  .where(
    and(
      eq(userProgress.user_id, userId),
      lt(userProgress.next_review, todayEnd),
      eq(userProgress.mastered, false)
    )
  );

reviewCount = result[0]?.count || 0;
```

### 显示逻辑

- 如果 `reviewCount > 0`，显示橙色提醒卡片
- 显示待复习单词数量
- 提供 "Review Now →" 按钮跳转到 `/review`

---

## 🗄️ 数据库结构

### `user_progress` 表

| 字段 | 类型 | 说明 |
|-----|------|------|
| `id` | integer | 主键 |
| `user_id` | text | 用户ID（Supabase Auth UUID） |
| `word_id` | integer | 单词ID（外键关联 `words` 表） |
| `last_reviewed` | timestamp | 最后复习时间 |
| `next_review` | timestamp | **下次复习时间**（核心字段） |
| `mastered` | boolean | 是否已完全掌握 |

### 索引

- `user_progress_user_word_unique`：`(user_id, word_id)` 联合唯一索引
- `user_progress_user_next_review_idx`：`(user_id, next_review)` 联合索引（优化复习查询）

---

## 🔧 关键函数说明

### 1. `createReviewRecords()` 

**位置**：`lib/practice-utils.ts`

**功能**：为练习会话中的每个单词创建/更新复习记录

**参数**：
```typescript
interface WordResult {
  wordId: number;
  isCorrect: boolean;
}
```

**流程**：
1. 遍历 `wordResults` 数组
2. 为每个单词调用 `/api/progress` API
3. 传递 `{ wordId, known: isCorrect, isReview: false }`
4. 使用 `Promise.allSettled()` 允许部分失败

### 2. `/api/progress` API

**位置**：`app/api/progress/route.ts`

**功能**：创建或更新 `user_progress` 记录

**请求体**：
```typescript
{
  wordId: number;
  known: boolean;      // true = 掌握, false = 未掌握
  isReview: boolean;  // true = 复习模式, false = 学习模式
}
```

**逻辑**：
1. 验证用户登录状态
2. 根据 `known` 和 `isReview` 计算 `next_review` 时间
3. 使用 UPSERT（`ON CONFLICT DO UPDATE`）更新记录
4. 更新 `last_reviewed` 和 `mastered` 字段

---

## ⚠️ 当前算法的局限性

### 1. 固定时间间隔

**现状**：
- 答对：1天后复习（学习模式）或 2天后复习（复习模式）
- 答错：1小时后复习（学习模式）或 10分钟后复习（复习模式）

**问题**：
- 没有考虑单词难度
- 没有根据历史表现动态调整
- 间隔增长不够平滑（1小时 → 1天 → 2天）

### 2. 缺少复习次数跟踪

**现状**：
- `user_progress` 表没有记录复习次数
- 无法判断单词的掌握程度（如：第1次复习 vs 第10次复习）

**建议改进**：
- 添加 `review_count` 字段
- 根据复习次数调整间隔（如：第1次复习后1天，第2次复习后3天，第3次复习后7天）

### 3. 没有考虑遗忘曲线理论

**现状**：
- 算法简单，没有基于艾宾浩斯遗忘曲线

**建议改进**：
- 实现 SM-2 算法（SuperMemo 2）或类似算法
- 根据遗忘曲线动态计算复习间隔

---

## 🚀 未来优化方向

### 1. 实现 SM-2 算法

```typescript
// 伪代码示例
interface SM2Progress {
  easeFactor: number;      // 难度系数（默认2.5）
  interval: number;        // 当前间隔（天）
  repetitions: number;     // 连续正确次数
}

function calculateNextReview(quality: number, progress: SM2Progress): SM2Progress {
  // quality: 0-5（0=完全遗忘，5=完全掌握）
  // 根据quality和progress计算新的interval和easeFactor
  // ...
}
```

### 2. 添加复习统计

- 记录每个单词的复习历史
- 分析用户的遗忘模式
- 个性化调整复习间隔

### 3. 智能复习提醒

- 根据用户活跃时间推送提醒
- 根据复习量动态调整每日复习量
- 提供"复习强度"选项（轻松/标准/强化）

---

## 📝 总结

### 当前复习系统特点

✅ **优点**：
- 自动创建复习记录（练习完成后）
- 简单易懂的算法
- 只显示Courses单词（架构统一）
- 显示课程来源信息
- 乐观更新（流畅的用户体验）

⚠️ **局限性**：
- 固定时间间隔（不够智能）
- 缺少复习次数跟踪
- 没有基于遗忘曲线理论

### 核心流程

1. **练习完成** → `createReviewRecords()` → 创建 `user_progress` 记录
2. **计算复习时间** → `/api/progress` → 根据表现设置 `next_review`
3. **查询待复习单词** → `app/review/page.tsx` → 显示 `next_review < 今天结束` 的单词
4. **用户复习** → `ReviewComponent.tsx` → 更新 `next_review` 时间
5. **首页提醒** → `app/page.tsx` → 显示待复习数量

---

**最后更新**：2025-11-01  
**版本**：v1.1

